#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int data;
    struct Node* leftChild;
    struct Node* rightChild;
} Node;

Node* treeRoot = NULL;

Node* createNode(int data) {
    Node* nodePtr = (Node*)malloc(sizeof(Node));
    nodePtr->data = data;
    nodePtr->leftChild = nodePtr->rightChild = NULL;
    return nodePtr;
}

Node* minValueNode(Node* node) {
    Node* tempNode = node;
    while (tempNode && tempNode->leftChild)
        tempNode = tempNode->leftChild;
    return tempNode;
}

Node* addNode(Node* node, int data) {
    if (node == NULL) return createNode(data);
    if (data < node->data)
        node->leftChild = addNode(node->leftChild, data);
    else if (data > node->data)
        node->rightChild = addNode(node->rightChild, data);
    else
        printf("Data %d already exists. Skipping insert.\n", data);
    return node;
}

int searchNode(Node* node, int data) {
    if (!node) return 0;
    if (data == node->data) return 1;
    if (data < node->data) return searchNode(node->leftChild, data);
    return searchNode(node->rightChild, data);
}

Node* removeNode(Node* node, int data) {
    if (!node) return node;

    if (data < node->data)
        node->leftChild = removeNode(node->leftChild, data);
    else if (data > node->data)
        node->rightChild = removeNode(node->rightChild, data);
    else {
        if (!node->leftChild) {
            Node* temp = node->rightChild;
            printf("Deleted %d\n", node->data);
            free(node);
            return temp;
        } else if (!node->rightChild) {
            Node* temp = node->leftChild;
            printf("Deleted %d\n", node->data);
            free(node);
            return temp;
        }
        Node* succ = minValueNode(node->rightChild);
        node->data = succ->data;
        node->rightChild = removeNode(node->rightChild, succ->data);
    }
    return node;
}

void inorder(Node* node) {
    if (!node) return;
    inorder(node->leftChild);
    printf("%d ", node->data);
    inorder(node->rightChild);
}

void preorder(Node* node) {
    if (!node) return;
    printf("%d ", node->data);
    preorder(node->leftChild);
    preorder(node->rightChild);
}

void postorder(Node* node) {
    if (!node) return;
    postorder(node->leftChild);
    postorder(node->rightChild);
    printf("%d ", node->data);
}

void displayMenu() {
    printf("\n--- BST Menu ---\n");
    printf("1. Insert\n2. Delete\n3. Search\n4. Display Traversals\n5. Exit\n");
    printf("Enter choice: ");
}

void displayTraversalMenu() {
    int ch;
    if (!treeRoot) {
        printf("BST is empty.\n");
        return;
    }
    printf("\n-- Traversal Options --\n");
    printf("1. Inorder\n2. Preorder\n3. Postorder\n");
    printf("Enter choice: ");
    scanf("%d", &ch);

    printf("Traversal: ");
    switch (ch) {
        case 1: inorder(treeRoot); break;
        case 2: preorder(treeRoot); break;
        case 3: postorder(treeRoot); break;
        default: printf("Invalid traversal choice."); return;
    }
    printf("\n");
}

int main() {
    int choice, data;
    while (1) {
        displayMenu();
        if (scanf("%d", &choice) != 1) return 0;

        switch (choice) {
            case 1:
                printf("Enter data to insert: ");
                scanf("%d", &data);
                treeRoot = addNode(treeRoot, data);
                break;
            case 2:
                if (!treeRoot) {
                    printf("BST empty. Nothing to delete.\n");
                    break;
                }
                printf("Enter data to delete: ");
                scanf("%d", &data);
                if (searchNode(treeRoot, data))
                    treeRoot = removeNode(treeRoot, data);
                else
                    printf("Data %d not found.\n", data);
                break;
            case 3:
                printf("Enter data to search: ");
                scanf("%d", &data);
                if (searchNode(treeRoot, data))
                    printf("Data %d found.\n", data);
                else
                    printf("Data %d not found.\n", data);
                break;
            case 4:
                displayTraversalMenu();
                break;
            case 5:
                return 0;
            default:
                printf("Invalid choice.\n");
        }
    }
} 
output:

--- BST Menu ---
1. Insert
2. Delete
3. Search
4. Display Traversals
5. Exit
Enter choice: 1
Enter data to insert: 50

--- BST Menu ---
Enter choice: 1
Enter data to insert: 30

--- BST Menu ---
Enter choice: 1
Enter data to insert: 70

--- BST Menu ---
Enter choice: 1
Enter data to insert: 20

--- BST Menu ---
Enter choice: 1
Enter data to insert: 40

--- BST Menu ---
Enter choice: 1
Enter data to insert: 60

--- BST Menu ---
Enter choice: 1
Enter data to insert: 80

--- BST Menu ---
Enter choice: 4

-- Traversal Options --
Enter choice: 1
Traversal: 20 30 40 50 60 70 80 

--- BST Menu ---
Enter choice: 3
Enter data to search: 60
Data 60 found.

--- BST Menu ---
Enter choice: 3
Enter data to search: 25
Data 25 not found.

--- BST Menu ---
Enter choice: 2
Enter data to delete: 20
Deleted 20

--- BST Menu ---
Enter choice: 2
Enter data to delete: 30
Deleted 30

--- BST Menu ---
Enter choice: 4

-- Traversal Options --
Enter choice: 1
Traversal: 40 50 60 70 80 

--- BST Menu ---
Enter choice: 2
Enter data to delete: 50
Deleted 50

--- BST Menu ---
Enter choice: 4

-- Traversal Options --
Enter choice: 2
Traversal: 60 40 70 80 

--- BST Menu ---
Enter choice: 5

